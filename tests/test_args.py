from datetime import date, timedelta

import pytest

from cfa_config_generator.utils.epinow2.constants import (
    all_diseases,
    all_states,
    nssp_states_omit,
)
from cfa_config_generator.utils.epinow2.functions import (
    extract_user_args,
    generate_default_job_id,
    generate_timestamp,
    parse_disease,
    parse_state,
    validate_args,
)


def test_extract_user_args(monkeypatch):
    """Tests default set of extract_user_args."""
    today = date.today()
    as_of_date = generate_timestamp()
    max_reference_date = today - timedelta(days=1)
    min_reference_date = today - timedelta(weeks=8)

    # Mock environment variables
    monkeypatch.setenv("report_date", today.isoformat())
    monkeypatch.setenv("production_date", today.isoformat())
    monkeypatch.setenv(
        "reference_dates",
        f"{min_reference_date.isoformat()},{max_reference_date.isoformat()}",
    )
    monkeypatch.setenv("data_container", "nssp-etl")
    monkeypatch.setenv("output_container", "test-container")
    # Let job_id be generated by default

    default_args = {
        "task_exclusions": None,
        "exclusions": None,
        "state": "all",
        "disease": "all",
        "report_date": today,
        "production_date": today,
        "reference_dates": [
            min_reference_date,
            max_reference_date,
        ],
        "data_path": f"gold/{today.isoformat()}.parquet",
        "data_container": "nssp-etl",
        "job_id": generate_default_job_id(as_of_date=as_of_date),
        "as_of_date": as_of_date,
        "output_container": "test-container",
    }

    extracted_args = extract_user_args(as_of_date=as_of_date)

    # Compare all keys except job_id which is non-deterministic
    assert {k: v for k, v in extracted_args.items() if k != "job_id"} == {
        k: v for k, v in default_args.items() if k != "job_id"
    }
    assert "Rt-estimation" in extracted_args["job_id"]


def test_validate_args_default():
    """Tests validate_args with default arguments."""
    report_date = production_date = date.today()
    as_of_date = generate_timestamp()
    max_reference_date = report_date - timedelta(days=1)
    min_reference_date = report_date - timedelta(weeks=8)

    validated_args = validate_args(
        state="all",
        disease="all",
        exclusions=None,
        report_date=report_date,
        production_date=production_date,
        reference_dates=[min_reference_date, max_reference_date],
        data_path=f"gold/{report_date.isoformat()}.parquet",
        data_container="test-container",
        job_id="test-job-id",
        as_of_date=as_of_date,
        output_container="test-container",
    )
    assert validated_args == {
        "state": list(set(all_states) - set(nssp_states_omit)),
        "disease": all_diseases,
        "exclusions": None,
        "reference_dates": [min_reference_date, max_reference_date],
        "report_date": report_date,
        "data_path": f"gold/{report_date.isoformat()}.parquet",
        "data_container": "test-container",
        "production_date": date.today(),
        "job_id": "test-job-id",
        "as_of_date": as_of_date,
        "output_container": "test-container",
    }


def test_invalid_state():
    """Tests that an invalid state raises a ValueError."""
    today = date.today()
    with pytest.raises(ValueError):
        validate_args(
            state="invalid",
            disease="all",
            report_date=today,
            reference_dates=[today - timedelta(days=1), today - timedelta(days=2)],
            data_path="gold/",
            data_container="test-container",
            production_date=today,
            job_id="test-job-id",
            as_of_date=generate_timestamp(),
            output_container="test-container",
        )


def test_invalid_disease():
    """Tests that an invalid disease raises a ValueError."""
    today = date.today()

    with pytest.raises(ValueError):
        validate_args(
            state="all",
            disease="invalid",
            report_date=today,
            reference_dates=[today - timedelta(days=1), today - timedelta(days=2)],
            data_path="gold/",
            data_container="test-container",
            production_date=today,
            job_id="test-job-id",
            as_of_date=generate_timestamp(),
            output_container="test-container",
        )


def test_invalid_reference_date_logic():
    """Tests that reference dates after report date raise ValueError."""
    today = date.today()

    with pytest.raises(
        ValueError, match="Ensure all reference_dates are on or before the report date"
    ):
        validate_args(
            state="all",
            disease="all",
            report_date=today,
            # Invalid logic
            reference_dates=[
                today + timedelta(days=1),
                today + timedelta(days=2),
            ],
            data_path="gold/",
            data_container="test-container",
            production_date=today,
            job_id="test-job-id",
            as_of_date=generate_timestamp(),
            output_container="test-container",
        )


def test_invalid_disease_exclusion():
    """Tests that an invalid disease raises a ValueError."""
    today = date.today()
    as_of_date = generate_timestamp()
    # valid diseases are 'COVID-19', 'Influenza', or 'RSV'
    task_exclusions = "WA:mpox"

    with pytest.raises(ValueError, match="Disease mpox not recognized"):
        validate_args(
            state="WA",
            disease="all",
            report_date=today,
            reference_dates=[today - timedelta(days=1), today - timedelta(days=2)],
            data_path="gold/",
            data_container="test-container",
            production_date=today,
            job_id="test-job-id",
            as_of_date=as_of_date,
            task_exclusions=task_exclusions,
            output_container="test-container",
        )


@pytest.mark.parametrize(
    argnames="state_val, should_fail",
    argvalues=[
        # Test all
        ("all", False),
        # Test multiple
        ("WA, CA", False),
        ("WA,CA   , TX", False),
        ("WA,CA,TX,NY", False),
        # Test single
        ("OH", False),
        ("CA", False),
        ("WA ", False),
        (" WA", False),
        (" WA ", False),
        # Test failures,
        ("ZZ,WA", True),
        ("OH,WA,OO", True),
    ],
)
def test_state_parsing(state_val, should_fail):
    if should_fail:
        with pytest.raises(ValueError, match=r"State \w+ not recognized"):
            parse_state(state_val)
        return

    parsed_states: list[str] = parse_state(state_val)
    # Make sure the length of the state list is correct
    if state_val == "all":
        assert len(parsed_states) == len(set(all_states) - set(nssp_states_omit)), (
            "Should have correct number of states for 'all' case"
        )
    else:
        # Split the state_val by commas and check the length
        split_vals: list[str] = [state.strip() for state in state_val.split(",")]
        assert len(parsed_states) == len(split_vals)
        # Check that all states are in the validated args
        for s in split_vals:
            assert s in parsed_states


@pytest.mark.parametrize(
    argnames="disease_val, should_fail",
    argvalues=[
        # Test all
        ("all", False),
        # Test multiple
        ("COVID-19, Influenza", False),
        ("COVID-19,Influenza", False),
        ("COVID-19,Influenza,RSV", False),
        # Test single
        ("COVID-19", False),
        ("Influenza", False),
        ("RSV", False),
        (" RSV", False),
        ("COVID-19 ", False),
        (" COVID-19", False),
        (" COVID-19 ", False),
        # Test failures,
        ("ZZ,COVID-19", True),
        ("COVID-19,ZZ", True),
    ],
)
def test_disease_parsing(disease_val, should_fail):
    if should_fail:
        with pytest.raises(ValueError, match=r"Disease \w+ not recognized"):
            parse_disease(disease_val)
        return

    parsed_diseases: list[str] = parse_disease(disease_val)
    # Make sure the length of the disease list is correct
    if disease_val == "all":
        assert len(parsed_diseases) == len(all_diseases), (
            "Should have correct number of diseases for 'all' case"
        )
    else:
        # Split the disease_val by commas and check the length
        split_vals: list[str] = [disease.strip() for disease in disease_val.split(",")]
        assert len(parsed_diseases) == len(split_vals)
        # Check that all diseases are in the validated args
        for d in split_vals:
            assert d in parsed_diseases
