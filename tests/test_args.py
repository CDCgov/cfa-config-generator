from datetime import date, datetime, timedelta, timezone

import pytest

from cfa_config_generator.utils.epinow2.constants import all_diseases, nssp_valid_states
from cfa_config_generator.utils.epinow2.driver_functions import generate_backfill_config
from cfa_config_generator.utils.epinow2.functions import (
    extract_user_args,
    generate_default_job_id,
    generate_timestamp,
    parse_options,
    validate_args,
)


def test_extract_user_args(monkeypatch):
    """Tests default set of extract_user_args."""
    today = date.today()
    as_of_date = generate_timestamp()
    max_reference_date = today - timedelta(days=1)
    min_reference_date = today - timedelta(weeks=8)

    # Mock environment variables
    monkeypatch.setenv("report_date", today.isoformat())
    monkeypatch.setenv("production_date", today.isoformat())
    monkeypatch.setenv(
        "reference_dates",
        f"{min_reference_date.isoformat()},{max_reference_date.isoformat()}",
    )
    monkeypatch.setenv("data_container", "nssp-etl")
    monkeypatch.setenv("output_container", "test-container")
    # Let job_id be generated by default

    default_args = {
        "task_exclusions": None,
        "exclusions": None,
        "state": "all",
        "disease": "all",
        "report_date": today,
        "production_date": today,
        "reference_dates": [
            min_reference_date,
            max_reference_date,
        ],
        "data_path": f"gold/{today.isoformat()}.parquet",
        "data_container": "nssp-etl",
        "job_id": generate_default_job_id(as_of_date=as_of_date),
        "as_of_date": as_of_date,
        "output_container": "test-container",
        "facility_active_proportion": 1.0,
    }

    extracted_args = extract_user_args(as_of_date=as_of_date)

    # Compare all keys except job_id which is non-deterministic
    assert {k: v for k, v in extracted_args.items() if k != "job_id"} == {
        k: v for k, v in default_args.items() if k != "job_id"
    }
    assert "Rt-estimation" in extracted_args["job_id"]


def test_validate_args_default():
    """Tests validate_args with default arguments."""
    report_date = production_date = date.today()
    as_of_date = generate_timestamp()
    max_reference_date = report_date - timedelta(days=1)
    min_reference_date = report_date - timedelta(weeks=8)

    validated_args = validate_args(
        state="all",
        disease="all",
        report_date=report_date,
        production_date=production_date,
        reference_dates=[min_reference_date, max_reference_date],
        data_path=f"gold/{report_date.isoformat()}.parquet",
        data_container="test-container",
        job_id="test-job-id",
        as_of_date=as_of_date,
        output_container="test-container",
        facility_active_proportion=1.0,
        exclusions=None,
    )
    assert validated_args == {
        "state": list(nssp_valid_states),
        "disease": list(all_diseases),
        "exclusions": None,
        "reference_dates": [min_reference_date, max_reference_date],
        "report_date": report_date,
        "data_path": f"gold/{report_date.isoformat()}.parquet",
        "data_container": "test-container",
        "production_date": date.today(),
        "job_id": "test-job-id",
        "as_of_date": as_of_date,
        "output_container": "test-container",
        "facility_active_proportion": 1.0,
    }


def test_invalid_state():
    """Tests that an invalid state raises a ValueError."""
    today = date.today()
    with pytest.raises(ValueError):
        validate_args(
            state="invalid",
            disease="all",
            report_date=today,
            reference_dates=[today - timedelta(days=1), today - timedelta(days=2)],
            data_path="gold/",
            data_container="test-container",
            production_date=today,
            job_id="test-job-id",
            as_of_date=generate_timestamp(),
            output_container="test-container",
            facility_active_proportion=1.0,
        )


def test_invalid_disease():
    """Tests that an invalid disease raises a ValueError."""
    today = date.today()

    with pytest.raises(ValueError):
        validate_args(
            state="all",
            disease="invalid",
            report_date=today,
            reference_dates=[today - timedelta(days=1), today - timedelta(days=2)],
            data_path="gold/",
            data_container="test-container",
            production_date=today,
            job_id="test-job-id",
            as_of_date=generate_timestamp(),
            output_container="test-container",
            facility_active_proportion=1.0,
        )


def test_invalid_reference_date_logic():
    """Tests that reference dates after report date raise ValueError."""
    today = date.today()

    with pytest.raises(
        ValueError, match="Ensure all reference_dates are on or before the report date"
    ):
        validate_args(
            state="all",
            disease="all",
            report_date=today,
            # Invalid logic
            reference_dates=[
                today + timedelta(days=1),
                today + timedelta(days=2),
            ],
            data_path="gold/",
            data_container="test-container",
            production_date=today,
            job_id="test-job-id",
            as_of_date=generate_timestamp(),
            output_container="test-container",
            facility_active_proportion=1.0,
        )


def test_invalid_disease_exclusion():
    """Tests that an invalid disease raises a ValueError."""
    today = date.today()
    as_of_date = generate_timestamp()
    # valid diseases are 'COVID-19', 'Influenza', or 'RSV'
    task_exclusions = "WA:mpox"

    with pytest.raises(ValueError, match="Disease mpox not recognized"):
        validate_args(
            state="WA",
            disease="all",
            report_date=today,
            reference_dates=[today - timedelta(days=1), today - timedelta(days=2)],
            data_path="gold/",
            data_container="test-container",
            production_date=today,
            job_id="test-job-id",
            as_of_date=as_of_date,
            output_container="test-container",
            facility_active_proportion=1.0,
            task_exclusions=task_exclusions,
        )


@pytest.mark.parametrize(
    argnames="raw_val, valid_opts, should_fail",
    argvalues=[
        # Test all
        ("all", all_diseases, False),
        ("all", nssp_valid_states, False),
        # Test multiple
        ("COVID-19, Influenza", all_diseases, False),
        ("COVID-19,Influenza", all_diseases, False),
        ("COVID-19,Influenza,RSV", all_diseases, False),
        ("WA, CA", nssp_valid_states, False),
        ("WA,CA   , TX", nssp_valid_states, False),
        ("WA,CA,TX,NY", nssp_valid_states, False),
        (["OH ", "WA", "DC"], nssp_valid_states, False),
        # Test single
        ("COVID-19", all_diseases, False),
        ("Influenza", all_diseases, False),
        ("RSV", all_diseases, False),
        (" RSV", all_diseases, False),
        ("COVID-19 ", all_diseases, False),
        (" COVID-19", all_diseases, False),
        (" COVID-19 ", all_diseases, False),
        ("OH", nssp_valid_states, False),
        ("CA", nssp_valid_states, False),
        ("WA ", nssp_valid_states, False),
        (" WA", nssp_valid_states, False),
        (" WA ", nssp_valid_states, False),
        # Test failures,
        ("ZZ,COVID-19", all_diseases, True),
        ("COVID-19,ZZ", all_diseases, True),
        ("ZZ,WA", nssp_valid_states, True),
        ("OH,WA,OO", nssp_valid_states, True),
        (32, nssp_valid_states, True),
    ],
)
def test_option_parsing(raw_val, valid_opts, should_fail):
    if should_fail:
        with pytest.raises(ValueError, match=r"Option?s .+ not recognized"):
            parse_options(raw_input=raw_val, valid_options=valid_opts)
        return

    parsed_options: list[str] = parse_options(
        raw_input=raw_val, valid_options=valid_opts
    )
    # Make sure the length of the list is correct
    if raw_val == "all":
        assert len(parsed_options) == len(valid_opts), (
            "Should have correct number of options for 'all' case"
        )
    else:
        # Split the raw_val by commas and check the length
        split_vals: list[str] = (
            [opt.strip() for opt in raw_val.split(",")]
            if isinstance(raw_val, str)
            else [opt.strip() for opt in raw_val]
        )
        assert len(parsed_options) == len(split_vals)
        # Check that all options are in the validated args
        unexpected_vals = set(split_vals).difference(valid_opts)
        assert len(unexpected_vals) == 0, (
            f"Unexpected values in {raw_val}: {unexpected_vals}"
        )


def test_generate_backfill_bad_lists():
    """
    Tests that we error out when we hand lists of different lengths to the backfill
    function.
    """
    state = "all"
    disease = "all"
    reference_date_time_span = "8w"
    data_container = "nssp-etl"
    backfill_name = "nate-backfill-test"
    output_container = "rt-epinow2-config"
    report_dates: list[date] = [
        date(2025, 5, 14) - timedelta(weeks=i) for i in range(5)
    ]
    data_paths: list[str] = [
        f"gold/{date.isoformat()}.parquet" for date in report_dates
    ][:-1]
    as_of_dates: list[datetime] = [datetime.now(timezone.utc).isoformat()] * len(
        report_dates
    )
    with pytest.raises(
        ValueError,
        match="report_dates, data_paths, and as_of_dates must all be the same length",
    ):
        generate_backfill_config(
            state=state,
            disease=disease,
            report_dates=report_dates,
            reference_date_time_span=reference_date_time_span,
            data_paths=data_paths,
            data_container=data_container,
            backfill_name=backfill_name,
            as_of_dates=as_of_dates,
            output_container=output_container,
            facility_active_proportion=1.0,
        )
